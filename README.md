# Совкод (.ussr) Транслятор и модель

- `alg | acc | harv | hw | instr | binary | stream | port | pstr | prob1 | 8bit`
- Без усложнения

Задание к лабораторной [lab3-task.md](lab3-task.md).
Персональный вариант в файле [variant.md](variant.md).

## Язык программирования

Синтаксис языка должен напоминать java/javascript/lua. Должен поддерживать математические выражения.

- необходимо объяснить, как происходит отображение больших выражений на регистры и память;
- необходимо продемонстрировать работу транслятора в случае, если количество регистров недостаточно для реализации
  алгоритма.

Язык назовём Совкод (`☭★Cоветский код★☭`)

### Типы данных

- цел - целочисленный (int)
- вещ - вещественный (float тип)
- симв - символьный (char тип)
- строка (указатель на строку в памяти)
  того 6 типов данных

### Операции

- `+ - / *` (классические операции сложения, вычитания, деления и умножения соотв.)
- `% ^ ~` мат. операции остаток от деления, возведение в степень и взятие корня.
- `!` логическое отрицание
- `&` побитовая конъюнкция
- `|` побитовая дизъюнкция
- `< > ==` отношения (меньше, больше и равно соответственно)
- `(переменная)++` `(переменная)--` операции инкремент и декремент соотв.
- `\>> (переменная)` чтение из потока ввода 1 символа
- `\<< (переменная)` запись в файл вывода 1 символа

### Выражения

#### `Если` Оператор условия (if)

* Оператор если выполняет код внутри блока {} при истинности логического выражения в скобках ().
* В случае ложности выражения, код в блоке иначе выполняется (если он присутствует).
* Пример:

> `если` _(...)_ { кол_во++; }  
> `иначе` { кол-во--; }

#### `Пока` - оператор цикла (while)

Оператор пока выполняет код внутри блока {} до тех пор, пока логическое выражение в скобках () истинно.
Пример:
> `пока` _((кол_во > 12) & (a + b == 12))_ {...}

`/*` _текст комментария_ `*/` - комментарии

#### Логическое выражение

Логические выражения могут содержать сравнения, логические операторы (&, |, !), и могут быть вложены в скобки.
Пример:
> ((кол_во > 12) & (a + b == 12))

#### Комментарии:

* Комментарии начинаются с символа # и распространяются до конца строки.
* Пример:

> цел а = 5; `# Это комментарий`

### Формальное описание синтаксиса

<details><summary>Формальное описание Совкода по форме Бэкуса-Наура</summary>

``` ebnf
    <Совкод> ::= { <Объявление> | <Оператор> | <Комментарий> }
    
    <Объявление> ::= <Тип> <Идентификатор> {, <Идентификатор>} ;
    
    <Тип> ::= "цел" | "вещ" | "симв" | "строка"
    
    <Идентификатор> ::= <Буква> {<Буква> | <Цифра>}
    
    <Буква> ::= "a" | "b" | ... | "z" | "A" | "B" | ... | "Z" | "_"
    
    <Цифра> ::= "0" | "1" | ... | "9"
    
    <Оператор> ::= "если" "(" <Логическое_выражение> ")" "{" <Код> "}" ["иначе" "{" <Код> "}"]
     | "пока" "(" <Логическое_выражение> ")" "{" <Код> "}"
     | "#" <Текст_комментария>
     | <Выражение> ";"
    
    <Логическое_выражение> ::= <Сравнение> | <Логическое_выражение> "&" <Логическое_выражение>
     | <Логическое_выражение> "|" <Логическое_выражение>
     | "!" <Логическое_выражение>
    
    <Сравнение> ::= <Арифметическое_выражение> ("<" | ">" | "==") <Арифметическое_выражение>
    
    <Арифметическое_выражение> ::= <Терм> {"+" | "-" <Терм>}
    
    <Терм> ::= <Фактор> {"*" | "/" <Фактор>}
    
    <Фактор> ::= <Операнд> {"%" | "^" | "~" }
    
    <Операнд> ::= "(" <Логическое_выражение> ")"
     | <Идентификатор>
     | <Константа>
     | "\" ">>" "(" <Идентификатор> ")"
     | "\" "<<" "(" <Идентификатор> ")"
    
    <Константа> ::= <Целое> | <Вещественное> | <Логическое> | <Символьное>
    
    <Целое> ::= <Цифра> {<Цифра>}
    
    <Вещественное> ::= <Целое> "." <Целое>
    
    <Символьное> ::= "'" <Символ> "'"
    
    <Символ> ::= <Буква> | <Цифра> | ... | <Спецсимвол>
    
    <Спецсимвол> ::= "@", "#", "$", ...
    
    <Код> ::= { <Объявление> | <Оператор> }
    
    <Комментарий> ::= "#" <Текст_комментария>
    
    <Текст_комментария> ::= <Любой_текст_комментария>
    
    <Любой_текст_комментария> ::= {<Любой_символ>}
    
    <Любой_символ> ::= <Буква> | <Цифра> | <
    
     <
     Спецсимвол> | " " | "," | "." | ";" | "(" | ")" | "{" | "}" | "'" | "\" | "=" | "!" | "&" | "|" | "<" | ">" | "+" | "-" | "*" | "/" | "%" | "^" | "~"
     ... Как-то так
```
</details>

Таким образом, семантика ☭★Совкода★☭ определяет порядок выполнения кода, правила объявления переменных,
структуру условных операторов и циклов, а также различные операции, которые могут быть использованы в программах на этом
языке.

## Компилятор Совкода _Stalin_

`stalin <путь до исходника .ussr> <имя бинарника>`

### Входные данные

* Имя файла с исходным кодом в текстовом виде.
* Имя файла для сохранения полученного машинного кода.

### Выходные данные

* В поток ошибок записывается ассемблерное представление кода
* В поток ошибок записывается память данных
* В поток ошибок записываются количества строк кода в реализации алгоритма, количество инструкций и количество байтов в
  бинарном файле в целом
* В файл записывает байткод программы

### Основные этапы компиляции

pass

## Система команд

Аргумент может быть 
* NoneArg -- Не требуется
* DmemArg -- Указатель на память данных (dmem)
* PmemArg -- Pointer to program-memory (pmem)
* ValueArg -- Аргумент непосредственно
* IOPort -- Указатель на порт ввода вывода

| код | мнемоника  | тип  аргумента | 	тактов |                       	расшифровка	действия                       | подробно                                         |
|:----|:----------:|:--------------:|:-------:|:-----------------------------------------------------------------:|--------------------------------------------------|
| 0   |    nop	    |    NoneArg	    |    	    |                         операция простоя	                         |                                                  |
| 1   |   halt	    |    NoneArg	    |   0	    |                         сигнал остановки	                         |                                                  |
| 2   |    ldm	    |    DmemArg	    |    	    |              загрузить знач из памяти данных в acc	               | acc = dmem[arg]; c = const; z = (dmem[arg] == 0) |
| 3   |    ldi	    |    ValueArg    |    	    |              загрузить знач из памяти команд в acc	               | acc = arg; c = const; z = (arg == 0)             |
| 4   |   save	    |    DmemArg	    |    	    |         выгрузить значение аккумулятора в ячейку памяти	          | dmem[arg] = acc	                                 |
| 10  |    add	    |    DmemArg	    |    	    |            добавить значение из ячейки к аккумулятору	            | acc + dmem[arg]                                  |
| 11  |    sub	    |    DmemArg	    |    	    |             вычесть значение ячейки из аккумулятора	              | acc - dmem[arg]                                  |
| 12  |    cmp	    |    DmemArg	    |    	    | сравнить код из аккумулятора c ячейкой памяти, выставить регистры | 	z = (dmem[arg] == acc); c = (acc < dmem[arg])   |
| 13  |   incr	    |    NoneArg	    |    	    |               инкрементирует значение аккумулятора	               | x                                                |
| 14  |   decr	    |    NoneArg	    |    	    |               декрементирует значение аккумулятора	               | x                                                |
| 15  |    lsl	    |    ValueArg    |    	    |           бит. сдвиг влево, устанавливается флаг c в с	           | x                                                |
| 16  |    lsr	    |    ValueArg    |    	    |           бит. сдвиг вправо, устанавливается флаг c в	            | x                                                |
| 17  |   clrc	    |    NoneArg	    |    	    |              сбрасывает значение флага переполнения	              | x                                                |
| 18  |   clrz	    |    NoneArg	    |    	    |               сбрасывает значение нулевого флага		                | x                                                |
| 20  |    and	    |    DmemArg	    |    	    |                         логическое и acc	                         | acc & dmem[arg]                                  |
| 21  |     or     |    DmemArg	    |    	    |                        логическое или    	                        | acc  \| dmem[arg]                                |
| 22  |    not	    |    NoneArg	    |    	    |                        логическое не acc	                         | !acc                                             |
| 23  |    btn	    |    NoneArg	    |    	    |                         побитовое не acc	                         | ~acc                                             |
| 24  |    xor	    |    DmemArg	    |    	    |                        логический xor acc	                        | acc xor dmem[arg]	                               |
| 30  |    jmp	    |    PmemArg	    |    	    |                    совершить переход на pmem	                     | pc = pmem[arg]                                   |
| 31  |    jz	     |    PmemArg	    |    	    |          переход на pmem при установленом zero флаге 1	           | z == 1 ? pc = pmem[arg]                          |
| 32  |    jnz	    |    PmemArg	    |    	    |         переход на pmem при неустановленом zero флаге 0	          | z == 0 ? pc = pmem[arg]	                         |
| 40  |   mult	    |    DmemArg	    |    	    |          умножить аккумулятор на знанч. из ячейки пам.	           | acc = acc * dmem[arg]                            |
| 41  |    dev	    |    DmemArg	    |    	    |          разделить аккумулятор на знанч. из ячейки пам.	          | acc = acc / dmem[arg]                            |
| 42  |    mod	    |    DmemArg	    |    	    |         остаток от деления аккумулятора на знанч.ячейки	          | acc = acc % dmem[arg]                            |
| 43  |    pow	    |    DmemArg	    |    	    |          возвести аккумулятор в степень из ячейки пам.	           | acc ^ dmem[arg]                                  |
| 44  |   sqrt	    |    NoneArg	    |    	    |               подсчитать корень знач. аккумулятора	               | sqrt(acc)	                                       |
| 50  |    in	     |    IOport	     |    	    |           Ввод символьного значения с внешнего устр-ва	           | input >> dmem[arg]                               |
| 51  |    out	    |    IOport	     |    	    |          Вывод символьного значения на внешнее устр-во	           | dmem[arg] >> output                              |


## Структура памяти


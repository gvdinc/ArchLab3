# Лабораторная работа №3. На кончиках пальцев

Цель:

- экспериментальное знакомство с устройством процессоров через моделирование;
- получение опыта работы с компьютерной системой на нескольких уровнях организации, разрешая противоречия между ними.

Данная лабораторная работа носит практический характер. Она включает разработку:

- языка программирования и транслятора;
- системы команд;
- модели процессора и его принципиальной схемы;
- нескольких алгоритмов (реализация и тестирование работы).

Дополнительно:

- работа с CI;
- средства автоматического контроля качества кода;
- автоматическое тестирование.

Пример отчёта и реализаций транслятора и модели процессора: [Brainfuck](https://github.com/ryukzak/brainfuck).

**Примечание 1**: данная лабораторная работа не ставит перед собой задачу разработки промышленного компилятора, виртуальной машины, языка программирования или системы команд. Она подразумевает целый ряд упрощений, направленных на сокращение объёма работы. К примеру: отсутствие "внятных" сообщений об ошибках; отсутствие нормального тестирования на "некорректных" исходных и машинных кодах, отсутствие формульной проверки разработанного языка программирования, "архитектура программы по заветам ООП" и т.п.

**Примечание 2**: приведённый пример имеет очень много документации в коде, часть из которой продублирована в отчёте. Вам НЕ требуется иметь такой уровень документации.

## Структура проекта

```text
    Язык программирования
        |                                          ввод
        |                      Система команд        |
        |                           |                v
        |     +------------+        |          +------------+
   -----*---->| Транслятор |--------*--------->|   Модель   |----> журнал
    алгоритм  +------------+   машинный код    | процессора |      работы
                                               +------------+
                                                     |
                                                     v
                                                   вывод
```

Подробности -- ниже.

## Структура отчёта

В шапке необходимо указать:

- ФИО, группу;
- ваш вариант, отформатированный как код одной строкой;
- С или без усложнения.

### Язык программирования

Раздел должен включать:

- Описание [синтаксиса](https://ru.wikipedia.org/wiki/Синтаксис_(программирование)). Рекомендуется использовать [форму Бэкуса-Наура](https://ru.wikipedia.org/wiki/Форма_Бэкуса_—_Наура).
- Описание [семантики](https://ru.wikipedia.org/wiki/Семантика_(программирование)). В первую очередь:
    - [стратегия вычислений](https://ru.wikipedia.org/wiki/Стратегия_вычисления),
    - [области видимости](https://ru.wikipedia.org/wiki/Область_видимости),
    - типизация, виды литералов.
- Данного описания должно быть достаточно для выполнения программы "на листе бумаги".

### Организация памяти

Данный раздел является сквозным по отношению к работе и должен включать:

- модель памяти процессора, размеры машинного слова, варианты адресации;
- механику отображения программы и данных на процессор.

Модель памяти должна включать:

- Какие виды памяти и регистров доступны программисту?
- Где хранятся инструкции, процедуры и прерывания?
- Где хранятся статические и динамические данные?

```text
       Registers
+------------------------------+
| acc                          |
+------------------------------+

       Instruction memory
+------------------------------+
| 00  : jmp N                  |
|    ...                       |
| 10  : interruption vector 0  |
| 11  : interruption vector 1  |
|    ...                       |
| n   : program start          |
|    ...                       |
| i   : interruption handler 0 |
| i+1 : interruption handler 0 |
|    ...                       |
+------------------------------+

          Data memory
+------------------------------+
| 00  : constant 1             |
| 01  : constant 2             |
|    ...                       |
| l+0 : num literals           |
| l+1 : num literals           |
|    ...                       |
| c+0 : variable 1             |
|    ...                       |
+------------------------------+
```

А также данный раздел должен включать в себя описание того, как происходит работа с 1) литералами, 2) константами, 3) переменными, 4) инструкциями, 5) процедурами, 6) прерываниями во время компиляции и исполнения. К примеру:

- В каких случаях литерал будет использован при помощи непосредственной адресации?
- В каких случаях литерал будет сохранён в статическую память?
- Как будут размещены литералы, сохранённые в статическую память, друг относительно друга?
- Как будет размещаться в память литерал, требующий для хранения несколько машинных слов?
- В каких случаях переменная будет отображена на регистр?
- Как будет разрешаться ситуация, если регистров недостаточно для отображения всех переменных?
- В каких случаях переменная будет отображена на статическую память?
- В каких случаях переменная будет отображена на стек?
- И так далее по каждому из пунктов в зависимости от варианта...

### Система команд

Раздел должен включать:

- Особенности процессора (всё необходимое для понимания системы команд):
    - типы данных и машинных слов;
    - устройство памяти и регистров, адресации;
    - устройство ввода-вывода;
    - поток управления и системы прерываний;
    - и т.п.
- Набор инструкций.
- Способ кодирования инструкций:
    - по умолчанию можно использовать современные структуры данных;
    - требование бинарного кодирования -- особенность конкретного варианта.
- Описания системы команд должно быть достаточно для её классификации (CISC, RISC, Acc, Stack).

### Транслятор

Раздел подразумевает разработку консольного приложения:

- *Входные данные*:
    - Имя файла с исходным кодом в текстовом виде.
    - Имя файла для сохранения полученного машинного кода.
    - Другие аргументы командной строки (ключи, настройки, и т.п.).
- *Выходные данные*:
    - Имя выходного файла для машинного кода.

Раздел должен включать описание:

- Интерфейса командной строки.
- Принципов работы разработанного транслятора (этапы, правила и т.п.).

### Модель процессора

Раздел подразумевает разработку консольного приложения:

- *Входные данные*:
    - Имя файла для чтения машинного кода.
    - Имя файла с данными для имитации ввода в процессор.
- *Выходные данные*:
    - Вывод данных из процессора.
    - Журнал состояний процессора, включающий:
        - состояния регистров процессора;
        - выполняемые инструкции (возможно, микрокод) и соответствующие им исходные коды;
        - ввод/вывод из процессора.

Раздел должен включать:

- Схемы DataPath и ControlUnit, описание сигналов и флагов:
    - В случае, если схемы DataPath и ControlUnit совмещены, должна быть убедительная аргументация в тексте отчёта.
    - Не стоит полностью отрисовывать сигнальные линии от ControlUnit ко всем элементам схемы, это загромождает схему и усложняет её чтение. Обозначьте их как сделано в примере.
    - Если вы настаиваете на полной отрисовке сигнальных линий, то они должны визуально отличаться от линий передачи данных / адресов.
    - Схемы должны помещаться на экран.
    - В случае, если схемы не соответствуют данным требованиям, они могут быть признаны нечитаемыми, следовательно, непроверяемыми. Пример нечитаемой схемы: [link](./fig/lab3-bad-processor-scheme.png)
- Особенности реализации процесса моделирования.

Обратите внимание, что схемы должны отражать аппаратную структуру процессора и его элементов. Делайте схемы читаемыми. На структурных элементах отображайте порты (если у вас две стрелки в регистр -- это ошибка), не забывайте мультиплексоры.

Рекомендации по реализации:

- строгое разделение DataPath и ControlUnit на уровне кода/интерфейсов/схем;
- реализации машинной арифметики на уровне схем не требуется, просто складывайте и умножайте при создании модели;
- при моделировании процессов ориентироваться на схему процессора и её функционирование (а не писать отвлечённый код).

### Тестирование

Раздел должен включать:

- Краткое описание разработанных тестов.
- Описание работы настроенного CI.
- Реализацию следующих алгоритмов (должны проверяться в рамках интеграционных тестов):

    1. `hello` -- напечатать hello world;

    1. `cat` -- печатать данные, поданные на вход симулятору через файл ввода;

    1. `hello_user_name` -- запросить у пользователя его имя, считать его, вывести на экран приветствие (`<` -- ввод пользователя через файл ввода, `>` вывод симулятора):

        ```text
        > What is your name?
        < Alice
        > Hello, Alice!
        ```

    1. алгоритм согласно варианту;

    1. дополнительные алгоритмы, демонстрирующие особенности вашего варианта (синтаксис, работу специфических команд и т.п.).

- Необходимо показать работу разработанных алгоритмов.
    - Для одной из программ сделать подробное описание с комментариями в рамках отчёта, включая: использование разработанных программ, исходный код, машинный код, результат работы и журнал состояний модели процессора.
    - Для всех алгоритмов необходимо привести ссылки на их golden тесты. Они должны включать: алгоритм, машинный код и данные, ввод/вывод, журнал работы процессора.
    - Если размер журнала модели процессора слишком большой (сотни килобайт), его полное включение в golden test нецелесообразно. Необходимо адаптировать журнал под каждый алгоритм, добившись достаточной репрезентативности для проверки задания.
    - Все листинги исходного кода должны быть отформатированы.

Кроме того, в конце отчёта необходимо привести следующий текст для трёх реализованных алгоритмов (необходимо для сбора общей аналитики по проекту):

```text
| ФИО | <алг> | <LoC> | <code байт> | <code инстр.> | <инстр.> | <такт.> | <вариант> |
```

где:

- алг. -- название алгоритма (hello, cat, или как в варианте)
- прог. LoC -- кол-во строк кода в реализации алгоритма
- code байт -- кол-во байт в машинном коде (если бинарное представление)
- code инстр. -- кол-во инструкций в машинном коде
- инстр. -- кол-во инструкций, выполненных при работе алгоритма
- такт. -- кол-во тактов, которое заняла работа алгоритма

## Требования к реализации

- рекомендуемый язык разработки: Python (иные варианты требуют предварительного согласования);
- помимо непосредственной реализации, необходимы:
    - разработка интеграционных тестов для алгоритмов в форме **golden test-ов**, которые включают:
        - входной алгоритм;
        - конфигурацию транслятора и/или модели (если необходима);
        - машинный код (с мнемониками, если ваш вариант подразумевает бинарное представление);
        - журнал моделирования;
        - вывод результатов моделирования.
    - демонстрация реализации особенностей вашего варианта;
- тесты должны быть структурированными и читаемыми;
- исходный код должен быть отформатирован, включая код на вашем языке программирования;
- публикация кода на Github/Gitlab с настроенным CI, включая lint tools и автоформаттер;
    - для Python: ruff, mypy;
    - настройки инструментария должны быть "суровыми". Отключение проверок должно быть аргументированными.
- допускается использование шаблонов при настройке CI, при понимании его работы.

Возможно использование других языков, но, чтобы язык попал в "разрешённые", необходимо:

- поставить эксперимент, успешно выполнить задание и убедить преподавателя, что язык подходит;
- сформировать шаблон проекта, включая CI;
- эксперимент:
    - только по согласованию;
    - не более 2 экспериментов на язык на поток;
    - полировка шаблона/примера станет для вас частью задания, если язык окажется подходящим;
    - эксперимент будет оценён, даже если язык не подойдёт;
- рекомендуемые языки для экспериментов: Julia, Go, Rust, Haskell, Agda, Ocaml.

Нерекомендованные языки:

- Java -- показанные ранее проекты болели overengineering-ом в тяжёлой степени из-за слишком активного использования ООП.

## Варианты

Вариант определяется:

- комбинацией особенностей реализации;
- реализуемым алгоритмом;
- усложнением (требуется только в случае, если вы претендуете на максимальный балл).

| Особенность             |          |        |         |       |
|-------------------------|----------|--------|---------|-------|
| ЯП. Синтаксис           | alg      | lisp   | asm     | forth |
| Архитектура             | acc      | cisc   | risc    | stack |
| Организация памяти      | neum     | harv   |         |       |
| Control Unit            | hw       | mc     |         |       |
| Точность модели         | instr    | tick   |         |       |
| Представление маш. кода | struct   | binary |         |       |
| Ввод-вывод              | stream   | trap   |         |       |
| Ввод-вывод ISA          | mem      | port   |         |       |
| Тип строк               | cstr     | pstr   |         |       |
| Алгоритм                | prob1    | prob2  | prob5   |       |
| Усложнение              | pipeline | 8bit   | [4]char | spi   |

Пример варианта: `alg | cisc | neum | hw | instr | binary | stream | port | pstr | prob2 | 8bit`.

Как формировались варианты: [lab3variants.py](/src/lab3variants.py).

### Язык программирования. Синтаксис

- `alg` -- синтаксис языка должен напоминать java/javascript/lua. Должен поддерживать математические выражения.
    - необходимо объяснить, как происходит отображение больших выражений на регистры и память;
    - необходимо продемонстрировать работу транслятора в случае, если количество регистров недостаточно для реализации алгоритма.
- `lisp` -- синтаксис языка Lisp. S-exp.
    - требуется поддержка функций и/или процедур;
    - необходимо объяснить, как происходит отображение сложных выражений на регистры и память;
    - необходимо продемонстрировать работу транслятора в случае, если количества регистров недостаточно для реализации алгоритма.
    - Любое выражение (statement) -- expression. Примеры корректного кода (с точностью до ключевых слов):
        - `(print (if (= 1 x) "T" "F"))`
        - `(setq x (if (= 1 x) 2 3))`
        - `(setq x (loop ...))`
        - `(print (seq x 13))`
    - Необходимо объяснить и продемонстрировать, что любое выражение (statement) -- expression.
- `asm` -- синтаксис ассемблера. Необходима поддержка label-ов.
- `forth` -- синтаксис языка Forth с обратной польской нотацией.
    - Требуется поддержка процедур.

Примечание. Язык надо реализовывать по принципам:

- минимальной реализации;
- минимального удивления.

К примеру (ваш вариант `lisp`):

- (хорошо) Вам нужен цикл `for` и не нужен цикл `while`. Варианты:
    - Вы реализуете цикл через конструкцию `loop` (см. Common Lisp) и поддерживаете только `for`.
    - Вы реализуете синтаксис `loop - recur` (см. Clojure).
    - Вы реализуете рекурсивные вызовы с пониманием, как это работает и оптимизируется.
    - Иные варианты.
- (хорошо) Традиционно языки семейства `lisp` поддерживают переменное кол-во аргументов `(+ 1 2 3)`, вы пишете в коде `(+ 1 (+ 2 3))`.
- (плохо) У вас есть код: `(setq a (if (= x 0) 1 2))`.
    - В качестве предиката в вашем коде используются только выражения.
    - Ваш транслятор не позволяет сделать вызов для переменной: `(setq a (if p 1 2))`.

### Архитектура

- `acc` -- система команд должна быть выстроена вокруг аккумулятора.
    - Инструкции -- изменяют значение, хранимое в аккумуляторе.
    - Ввод-вывод осуществляется через аккумулятор.
- `cisc` -- система команд должна содержать сложные инструкции:
    - переменная длина инструкций (некоторые инструкции не помещаются в машинное слово, даже в `struct` вариантах необходимо делать выборку за несколько шагов в явном виде);
    - арифметические операции, работающие с регистрами и памятью за одну операцию;
    - работа со специальными регистрами;
- `risc` -- система команд должна быть упрощенной, в духе RISC архитектур:
    - стандартизированная длина команд;
    - операции над данными осуществляются только в рамках регистров;
    - доступ к памяти и ввод-вывод -- отдельные операции (с учётом специфики вашего варианта `mem/port`);
- `stack` -- система команд должна быть стековой:
    - вместо регистров используется стек;
    - это не исключает и не заменяет наличие памяти команд и памяти данных.

### Архитектура организации памяти

Тип памяти -- однопортовая.

- `neum` -- фон Неймановская архитектура.
- `harv` -- Гарвардская архитектура.

### Control Unit

- `hw` -- hardwired. Реализуется как часть модели.
- `mc` -- microcoded.
    - В отчёте необходимо задокументировать уровень микроинструкций.
    - Моделирование должно выполняться с точностью до такта.
    - Микрокод должен быть сохранён в отдельной памяти для микропрограмм.
    - Модель процессора должна исполнять микрокод.

### Точность модели

- `instr` -- процессор необходимо моделировать с точностью до каждой инструкции (наблюдается состояние после каждой инструкции).
- `tick` -- процессор необходимо моделировать с точностью до такта, процесс моделирования может быть приостановлен на любом такте.

### Представление машинного кода

- `struct` -- в виде высокоуровневой структуры данных. Считается, что одна инструкция укладывается в одно машинное слово, за исключением CISC архитектур.
- `binary` -- бинарное представление.
    - Требуются настоящие бинарные файлы, а не текстовые файлы с `0` и `1`.
    - Требуется отладочный вывод в текстовый файл вида:

        ```text
        <address> - <HEXCODE> - <mnemonica>
        20 - 03340301 - add #01 <- 34 + #03
        ```

### Ввод-вывод

#### `stream`

Ввод-вывод осуществляется как поток токенов. Есть в примере. Логика работы:

- при старте модели у вас есть буфер, в котором представлены все данные ввода (`['h', 'e', 'l', 'l', 'o']`);
- при обращении к вводу (выполнение инструкции) модель процессора получает "токен" (символ) информации;
- если данные в буфере кончились -- останавливайте моделирование;
- вывод данных реализуется аналогично, по выполнении команд в буфер вывода добавляется ещё один символ;
- по окончании моделирования показать все выведенные данные;
- логика работы с буфером реализуется в рамках модели на Python.

#### `trap`

Ввод-вывод осуществляется токенами через систему прерываний. Логика работы:

- при старте модели у вас есть расписание ввода (`[(1, 'h'), (10, 'e'), (20, 'l'), (25, 'l'), (100, 'o')]`, где цифра -- момент поступления данных, символ -- токен);
- процессор имеет систему прерываний:
    - прерывания считаем внутренними;
    - обработка прерывания должна приводить к вызову реализованного пользователем программного кода;
    - обработчик прерывания реализуется программистом на вашем языке;
- в процессе моделирования идёт отсчёт времени в тактах, по наступлении события ввода -- происходит обработка прерывания;
- из журнала работы процессора должно быть ясно, работаете вы в прерывании или нет;
- вывод данных реализуется посимвольно, как в варианте `stream`, по выполнении команд в буфер вывода добавляется ещё один символ;
- по окончании моделирования показать все выведенные данные;
- ситуация наступления прерывания во время обработки прерывания должна быть проработана (способ -- на ваше усмотрение);
- логика работы с буферами реализуется в рамках модели на Python;
- не стоит путать "вызов прерывания" и "получение данных".

### Ввод-вывод ISA

Поддержка ввода-вывода с точки зрения системы команд.

- `mem` -- memory-mapped (порты ввода-вывода отображаются в память и доступ к ним осуществляется штатными командами),
    - отображение портов ввода-вывода в память должно конфигурироваться (можно hardcode-ом).
- `port` -- port-mapped (специальные инструкции для ввода-вывода)
    - адресация портов ввода-вывода должна присутствовать.

### Поддержка строк

Варианты:

- `cstr` -- Null-terminated (C string)
- `pstr` -- Length-prefixed (Pascal string)

Общие требования:

- Статические строки должны храниться в памяти данных.
- Один символ может храниться в одном машинном слове (несмотря на явную неэффективность).

### Алгоритм

- Входные данные должны подаваться через ввод.
- Результат должен быть подан на вывод.
- Формат ввода/вывода данных -- на ваше усмотрение.

#### prob1. Multiples of 3 or 5

[Project Euler. Problem 1](https://projecteuler.net/problem=1)

If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.

Find the sum of all the multiples of 3 or 5 below 1000.

#### prob2. Even Fibonacci numbers

[Project Euler. Problem 2](https://projecteuler.net/problem=2)

Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

#### prob5. Smallest multiple

[Project Euler. Problem 5](https://projecteuler.net/problem=5)

2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.

What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?

### Усложнение

Варианты:

- `pipeline` -- конвейерная организация работы процессора.
    - Количество стадий конвейера -- не менее 3.
- `8bit` -- машинное слово -- 8 бит (как для памяти команд, так и для памяти данных, если они разделены).
- `[4]char` -- машинное слово хранит до 4 символов.
    - ввод-вывод по-прежнему остаётся посимвольным.
- `spi` -- ввод-вывод реализуется через интерфейс SPI (один канал на отправку и получение).
    - необходима визуализация передачи данных через SPI.

## Оценка

- 0-5 баллов если (одно или более):
    - у вас не проходит CI,
    - нет golden test-ов,
    - нельзя посмотреть отчёт о работе CI прямо в репозитории,
    - нет существенных разделов отчёта.
- 5-15 баллов если (одно или более):
    - ваша реализация/документация не соответствует варианту,
    - у вас есть существенные ошибки в структурах data path и control unit,
    - вы не можете объяснить на пальцах, как это работает и как исправить ошибки.
- 15-30 баллов:
    - хорошо выполненная работа с несущественными ошибками, которые вы понимаете и можете объяснить, как должно быть,
    - вами приняты "странные решения", но вы можете их аргументировать,
    - лабораторная работа не переусложнена вами.
- 30-40 баллов -- вы взяли и успешно реализовали ваш вариант с усложнением.

Оценка [примера лаб. 3, Python](https://github.com/ryukzak/brainfuck): 20-25 баллов при хорошей защите. Почему не больше?

- Только интеграционные тесты.
- Нет типизации в реализации на Python.
- Не реализовано усложнение (так как отсутствует в варианте).

Типичные проблемы, которые не позволили получить высокий балл:

- интеграционные тесты реализованы альтернативным способом (не golden tests, что затрудняет проверку);
- данные программы являются частью кода инструкций, а не данных (к примеру: строка `hello` хранится как 5 инструкций записи константы в регистр);
- игнорирование рекомендаций lint tools без убедительной аргументации;
- вариант реализован не в полной мере или с ошибкой, к примеру:
    - "Это CISC процессор, но нет инструкций переменной длины".
    - "Это микрокод, но микрокодирование реализовано через словари микроинструкций".
    - "Это система прерываний, но нет обработчиков прерываний".
- наличие в репозитории лишних файлов (файлы ОС, файлы текстового редактора и т.п.), мёртвого кода;
- непонимание назначения мультиплексоров;
- непонимание, как устроены элементы структурных схем (кроме арифметики).

## Общие рекомендации по началу работы

К сожалению, нет универсального ответа на вопрос о том, как лучше делать эту лабораторную работу. Всё сильно зависит от того, какие у вас навыки и знания, какой вариант.

Я бы предложил вам делать её так:

1. Написать 1-2 синтетические программы на вашем (пока ещё воображаемом) ЯП, в которых будет:
    - ветвление,
    - цикл,
    - математика,
    - строки,
    - ввод/вывод,
    - что-то ещё, необходимое по вашему варианту.
2. Написать для них машинный код.
3. Нарисовать схемы процессора в первом приближении, чтобы убедиться, что ваш машинный код работоспособен.
4. Написать транслятор.
5. Написать симулятор процессора.
6. Реализовать ваши алгоритмы.
